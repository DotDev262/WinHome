import sys
import json
import os
import subprocess
import shutil

# Standard Neovim data directory on Windows
# %LOCALAPPDATA%\nvim-data\site\pack\winhome\start\
NVIM_DATA_DIR = os.path.expandvars(r"%LOCALAPPDATA%\nvim-data\site\pack\winhome\start")
# %LOCALAPPDATA%\nvim\init.lua
NVIM_CONFIG_DIR = os.path.expandvars(r"%LOCALAPPDATA%\nvim")
INIT_LUA_PATH = os.path.join(NVIM_CONFIG_DIR, "init.lua")

def log(msg):
    sys.stderr.write(f"[vim-plugin] {msg}\n")

def get_plugin_path(package_id):
    # package_id is usually "user/repo" e.g. "tpope/vim-fugitive"
    repo_name = package_id.split("/")[-1]
    return os.path.join(NVIM_DATA_DIR, repo_name)

def check_installed(args):
    package_id = args.get("packageId")
    path = get_plugin_path(package_id)
    is_installed = os.path.isdir(os.path.join(path, ".git"))
    return {"success": True, "data": is_installed}

def install(args, context):
    package_id = args.get("packageId")
    path = get_plugin_path(package_id)
    
    if os.path.isdir(path):
        log(f"Plugin {package_id} already exists.")
        return {"success": True, "changed": False}

    if context.get("dryRun"):
        log(f"Would git clone https://github.com/{package_id} to {path}")
        return {"success": True, "changed": False}

    url = f"https://github.com/{package_id}.git"
    log(f"Cloning {url}...")
    
    try:
        subprocess.check_call(["git", "clone", "--depth=1", url, path], stderr=sys.stderr, stdout=sys.stderr)
        return {"success": True, "changed": True}
    except subprocess.CalledProcessError as e:
        return {"success": False, "error": str(e)}

def uninstall(args, context):
    package_id = args.get("packageId")
    path = get_plugin_path(package_id)

    if not os.path.isdir(path):
        return {"success": True, "changed": False}

    if context.get("dryRun"):
        log(f"Would remove {path}")
        return {"success": True, "changed": False}

    log(f"Removing {path}...")
    try:
        def on_rm_error(func, path, exc_info):
            os.chmod(path, 0o777)
            func(path)

        shutil.rmtree(path, onerror=on_rm_error)
        return {"success": True, "changed": True}
    except Exception as e:
        return {"success": False, "error": str(e)}

def apply_config(config, context):
    # config structure:
    # {
    #   "extensions": [ "tpope/vim-fugitive" ],
    #   "settings": { "number": true }
    # }
    
    # 1. Install Extensions
    extensions = config.get("extensions", [])
    if isinstance(extensions, list):
        for ext in extensions:
            install({"packageId": ext}, context)

    # 2. Apply Settings
    if not os.path.exists(NVIM_CONFIG_DIR):
        os.makedirs(NVIM_CONFIG_DIR, exist_ok=True)

    lines = ["-- Generated by WinHome"]
    
    # Handling "settings" key
    settings = config.get("settings", {})

    for key, value in settings.items():
        if key == "theme":
             lines.append(f"vim.cmd('colorscheme {value}')")
        elif isinstance(value, bool) or (isinstance(value, str) and value.lower() in ("true", "false")):
            if isinstance(value, bool):
                val_str = "true" if value else "false"
            else:
                val_str = value.lower()
            lines.append(f"vim.opt.{key} = {val_str}")
        elif isinstance(value, str):
            lines.append(f"vim.opt.{key} = '{value}'")
        elif isinstance(value, int):
            lines.append(f"vim.opt.{key} = {value}")
    
    new_content = "\n".join(lines)
    
    # Check for changes
    if os.path.exists(INIT_LUA_PATH):
        with open(INIT_LUA_PATH, "r") as f:
            current_content = f.read()
        if current_content == new_content:
            return {"success": True, "changed": False}

    if context.get("dryRun"):
        log("Would update init.lua with new settings.")
        return {"success": True, "changed": False}

    with open(INIT_LUA_PATH, "w") as f:
        f.write(new_content)
    
    return {"success": True, "changed": True}

def main():
    try:
        raw_input = sys.stdin.read()
        if not raw_input: return
        request = json.loads(raw_input)
    except Exception as e:
        sys.stderr.write(f"Failed to parse input: {e}\n")
        sys.exit(1)

    command = request.get("command")
    args = request.get("args", {}) # For install/uninstall
    # For 'apply', the config payload IS the args passed from Engine
    # But Engine passes it as 'args' in PluginRunner.ExecuteAsync(..., pluginConfig)
    
    context = request.get("context", {})
    
    if command == "check_installed":
        result = check_installed(args)
    elif command == "install":
        result = install(args, context)
    elif command == "uninstall":
        result = uninstall(args, context)
    elif command == "apply":
        # For apply, 'args' contains the config dictionary
        result = apply_config(args, context)
    else:
        result = {"success": False, "error": f"Unknown command: {command}"}

    result["requestId"] = request.get("requestId")
    print(json.dumps(result))

if __name__ == "__main__":
    main()